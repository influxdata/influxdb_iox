#![deny(rust_2018_idioms)]
#![warn(
    missing_copy_implementations,
    missing_debug_implementations,
//     missing_docs, // fixme
    clippy::explicit_iter_loop,
    clippy::use_self
)]

//! This crate is an implementation detail. Please review the
//! documentation for influxdb2_client.

use std::io;

/// Transform a type into valid line protocol lines
///
/// This trait is to enable the conversion of `DataPoint`s to line protocol. It is unlikely that
/// you would need to implement this trait manually; use the `derive` annotations.
pub trait WriteDataPoint {
    /// Write this data point as line protocol. The implementor is responsible for
    /// properly escaping the data and ensuring that complete lines
    /// are generated.
    fn write_data_point_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write;
}

// The following are traits rather than free functions so that we can limit their implementations
// to only the data types supported for each of measurement, tag key, tag value, field key, field
// value, and timestamp. They are a private implementation detail and any custom implementations
// of these traits would be generated by a future derive trait.
pub trait WriteMeasurement {
    fn write_measurement_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write;
}

impl WriteMeasurement for String {
    fn write_measurement_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write,
    {
        str::write_measurement_to(self, w)
    }
}

impl WriteMeasurement for str {
    fn write_measurement_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write,
    {
        escape_and_write_value(self, MEASUREMENT_DELIMITERS, w)
    }
}

pub trait WriteTagKey {
    fn write_tag_key_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write;
}

impl WriteTagKey for String {
    fn write_tag_key_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write,
    {
        str::write_tag_key_to(self, w)
    }
}

impl WriteTagKey for str {
    fn write_tag_key_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write,
    {
        escape_and_write_value(self, TAG_KEY_DELIMITERS, w)
    }
}

pub trait WriteTagValue {
    fn write_tag_value_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write;
}

impl WriteTagValue for String {
    fn write_tag_value_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write,
    {
        str::write_tag_value_to(self, w)
    }
}

impl WriteTagValue for str {
    fn write_tag_value_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write,
    {
        escape_and_write_value(self, TAG_VALUE_DELIMITERS, w)
    }
}

pub trait WriteFieldKey {
    fn write_field_key_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write;
}

impl WriteFieldKey for String {
    fn write_field_key_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write,
    {
        str::write_field_key_to(self, w)
    }
}

impl WriteFieldKey for str {
    fn write_field_key_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write,
    {
        escape_and_write_value(self, FIELD_KEY_DELIMITERS, w)
    }
}

pub trait WriteFieldValue {
    fn write_field_value_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write;
}

impl WriteFieldValue for bool {
    fn write_field_value_to<W>(&self, mut w: W) -> io::Result<()>
    where
        W: io::Write,
    {
        write!(w, "{}", if *self { "t" } else { "f" })
    }
}

impl WriteFieldValue for f64 {
    fn write_field_value_to<W>(&self, mut w: W) -> io::Result<()>
    where
        W: io::Write,
    {
        write!(w, "{}", self)
    }
}

impl WriteFieldValue for i64 {
    fn write_field_value_to<W>(&self, mut w: W) -> io::Result<()>
    where
        W: io::Write,
    {
        write!(w, "{}i", self)
    }
}

impl WriteFieldValue for String {
    fn write_field_value_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write,
    {
        str::write_field_value_to(self, w)
    }
}

impl WriteFieldValue for str {
    fn write_field_value_to<W>(&self, mut w: W) -> io::Result<()>
    where
        W: io::Write,
    {
        w.write_all(br#"""#)?;
        escape_and_write_value(self, FIELD_VALUE_STRING_DELIMITERS, &mut w)?;
        w.write_all(br#"""#)
    }
}

pub trait WriteTimestamp {
    fn write_timestamp_to<W>(&self, w: W) -> io::Result<()>
    where
        W: io::Write;
}

impl WriteTimestamp for i64 {
    fn write_timestamp_to<W>(&self, mut w: W) -> io::Result<()>
    where
        W: io::Write,
    {
        write!(w, "{}", self)
    }
}

const MEASUREMENT_DELIMITERS: &[char] = &[',', ' '];
const TAG_KEY_DELIMITERS: &[char] = &[',', '=', ' '];
const TAG_VALUE_DELIMITERS: &[char] = TAG_KEY_DELIMITERS;
const FIELD_KEY_DELIMITERS: &[char] = TAG_KEY_DELIMITERS;
const FIELD_VALUE_STRING_DELIMITERS: &[char] = &['"'];

fn escape_and_write_value<W>(
    value: &str,
    escaping_specification: &[char],
    mut w: W,
) -> io::Result<()>
where
    W: io::Write,
{
    let mut last = 0;

    for (idx, delim) in value.match_indices(escaping_specification) {
        let s = &value[last..idx];
        write!(w, r#"{}\{}"#, s, delim)?;
        last = idx + delim.len();
    }

    w.write_all(value[last..].as_bytes())
}
