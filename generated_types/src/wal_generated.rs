// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod wal {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_POINT_VALUE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_POINT_VALUE: u8 = 5;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_POINT_VALUE: [PointValue; 6] = [
        PointValue::NONE,
        PointValue::I64Value,
        PointValue::U64Value,
        PointValue::F64Value,
        PointValue::BoolValue,
        PointValue::StringValue,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct PointValue(pub u8);
    #[allow(non_upper_case_globals)]
    impl PointValue {
        pub const NONE: Self = Self(0);
        pub const I64Value: Self = Self(1);
        pub const U64Value: Self = Self(2);
        pub const F64Value: Self = Self(3);
        pub const BoolValue: Self = Self(4);
        pub const StringValue: Self = Self(5);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 5;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::I64Value,
            Self::U64Value,
            Self::F64Value,
            Self::BoolValue,
            Self::StringValue,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::I64Value => Some("I64Value"),
                Self::U64Value => Some("U64Value"),
                Self::F64Value => Some("F64Value"),
                Self::BoolValue => Some("BoolValue"),
                Self::StringValue => Some("StringValue"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for PointValue {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for PointValue {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for PointValue {
        type Output = PointValue;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for PointValue {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for PointValue {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for PointValue {}
    pub struct PointValueUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_COLUMN_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_COLUMN_TYPE: i8 = 5;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_COLUMN_TYPE: [ColumnType; 6] = [
        ColumnType::I64,
        ColumnType::U64,
        ColumnType::F64,
        ColumnType::Tag,
        ColumnType::String,
        ColumnType::Bool,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ColumnType(pub i8);
    #[allow(non_upper_case_globals)]
    impl ColumnType {
        pub const I64: Self = Self(0);
        pub const U64: Self = Self(1);
        pub const F64: Self = Self(2);
        pub const Tag: Self = Self(3);
        pub const String: Self = Self(4);
        pub const Bool: Self = Self(5);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 5;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::I64,
            Self::U64,
            Self::F64,
            Self::Tag,
            Self::String,
            Self::Bool,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::I64 => Some("I64"),
                Self::U64 => Some("U64"),
                Self::F64 => Some("F64"),
                Self::Tag => Some("Tag"),
                Self::String => Some("String"),
                Self::Bool => Some("Bool"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for ColumnType {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ColumnType {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ColumnType {
        type Output = ColumnType;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ColumnType {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = i8::to_le(self.0);
            Self(b)
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let b = i8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ColumnType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ColumnType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_COLUMN_VALUE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_COLUMN_VALUE: u8 = 6;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_COLUMN_VALUE: [ColumnValue; 7] = [
        ColumnValue::NONE,
        ColumnValue::TagValue,
        ColumnValue::I64Value,
        ColumnValue::U64Value,
        ColumnValue::F64Value,
        ColumnValue::BoolValue,
        ColumnValue::StringValue,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ColumnValue(pub u8);
    #[allow(non_upper_case_globals)]
    impl ColumnValue {
        pub const NONE: Self = Self(0);
        pub const TagValue: Self = Self(1);
        pub const I64Value: Self = Self(2);
        pub const U64Value: Self = Self(3);
        pub const F64Value: Self = Self(4);
        pub const BoolValue: Self = Self(5);
        pub const StringValue: Self = Self(6);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 6;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::TagValue,
            Self::I64Value,
            Self::U64Value,
            Self::F64Value,
            Self::BoolValue,
            Self::StringValue,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::TagValue => Some("TagValue"),
                Self::I64Value => Some("I64Value"),
                Self::U64Value => Some("U64Value"),
                Self::F64Value => Some("F64Value"),
                Self::BoolValue => Some("BoolValue"),
                Self::StringValue => Some("StringValue"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for ColumnValue {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ColumnValue {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ColumnValue {
        type Output = ColumnValue;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ColumnValue {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ColumnValue {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ColumnValue {}
    pub struct ColumnValueUnionTableOffset {}

    pub enum EntryOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Entry<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Entry<'a> {
        type Inner = Entry<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Entry<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Entry { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args EntryArgs<'args>,
        ) -> flatbuffers::WIPOffset<Entry<'bldr>> {
            let mut builder = EntryBuilder::new(_fbb);
            if let Some(x) = args.entry_type {
                builder.add_entry_type(x);
            }
            builder.finish()
        }

        pub const VT_ENTRY_TYPE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn entry_type(&self) -> Option<EntryType<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<EntryType>>(Entry::VT_ENTRY_TYPE, None)
        }
    }

    impl flatbuffers::Verifiable for Entry<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<EntryType>>(
                    &"entry_type",
                    Self::VT_ENTRY_TYPE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct EntryArgs<'a> {
        pub entry_type: Option<flatbuffers::WIPOffset<EntryType<'a>>>,
    }
    impl<'a> Default for EntryArgs<'a> {
        #[inline]
        fn default() -> Self {
            EntryArgs { entry_type: None }
        }
    }
    pub struct EntryBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> EntryBuilder<'a, 'b> {
        #[inline]
        pub fn add_entry_type(&mut self, entry_type: flatbuffers::WIPOffset<EntryType<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<EntryType>>(
                    Entry::VT_ENTRY_TYPE,
                    entry_type,
                );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EntryBuilder<'a, 'b> {
            let start = _fbb.start_table();
            EntryBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Entry<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Entry<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Entry");
            ds.field("entry_type", &self.entry_type());
            ds.finish()
        }
    }
    pub enum EntryTypeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct EntryType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for EntryType<'a> {
        type Inner = EntryType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> EntryType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            EntryType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args EntryTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<EntryType<'bldr>> {
            let mut builder = EntryTypeBuilder::new(_fbb);
            if let Some(x) = args.delete {
                builder.add_delete(x);
            }
            if let Some(x) = args.write {
                builder.add_write(x);
            }
            builder.finish()
        }

        pub const VT_WRITE: flatbuffers::VOffsetT = 4;
        pub const VT_DELETE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn write(&self) -> Option<Write<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Write>>(EntryType::VT_WRITE, None)
        }
        #[inline]
        pub fn delete(&self) -> Option<Delete<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Delete>>(EntryType::VT_DELETE, None)
        }
    }

    impl flatbuffers::Verifiable for EntryType<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Write>>(
                    &"write",
                    Self::VT_WRITE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Delete>>(
                    &"delete",
                    Self::VT_DELETE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct EntryTypeArgs<'a> {
        pub write: Option<flatbuffers::WIPOffset<Write<'a>>>,
        pub delete: Option<flatbuffers::WIPOffset<Delete<'a>>>,
    }
    impl<'a> Default for EntryTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            EntryTypeArgs {
                write: None,
                delete: None,
            }
        }
    }
    pub struct EntryTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> EntryTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_write(&mut self, write: flatbuffers::WIPOffset<Write<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Write>>(EntryType::VT_WRITE, write);
        }
        #[inline]
        pub fn add_delete(&mut self, delete: flatbuffers::WIPOffset<Delete<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Delete>>(EntryType::VT_DELETE, delete);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EntryTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            EntryTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<EntryType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for EntryType<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("EntryType");
            ds.field("write", &self.write());
            ds.field("delete", &self.delete());
            ds.finish()
        }
    }
    pub enum WriteOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Write<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Write<'a> {
        type Inner = Write<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Write<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Write { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args WriteArgs<'args>,
        ) -> flatbuffers::WIPOffset<Write<'bldr>> {
            let mut builder = WriteBuilder::new(_fbb);
            if let Some(x) = args.points {
                builder.add_points(x);
            }
            builder.finish()
        }

        pub const VT_POINTS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn points(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point>>,
            >>(Write::VT_POINTS, None)
        }
    }

    impl flatbuffers::Verifiable for Write<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Point>>,
                >>(&"points", Self::VT_POINTS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct WriteArgs<'a> {
        pub points: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>,
            >,
        >,
    }
    impl<'a> Default for WriteArgs<'a> {
        #[inline]
        fn default() -> Self {
            WriteArgs { points: None }
        }
    }
    pub struct WriteBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> WriteBuilder<'a, 'b> {
        #[inline]
        pub fn add_points(
            &mut self,
            points: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Point<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Write::VT_POINTS, points);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WriteBuilder<'a, 'b> {
            let start = _fbb.start_table();
            WriteBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Write<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Write<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Write");
            ds.field("points", &self.points());
            ds.finish()
        }
    }
    pub enum I64ValueOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct I64Value<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for I64Value<'a> {
        type Inner = I64Value<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> I64Value<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            I64Value { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args I64ValueArgs,
        ) -> flatbuffers::WIPOffset<I64Value<'bldr>> {
            let mut builder = I64ValueBuilder::new(_fbb);
            builder.add_value(args.value);
            builder.finish()
        }

        pub const VT_VALUE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn value(&self) -> i64 {
            self._tab.get::<i64>(I64Value::VT_VALUE, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for I64Value<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i64>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct I64ValueArgs {
        pub value: i64,
    }
    impl<'a> Default for I64ValueArgs {
        #[inline]
        fn default() -> Self {
            I64ValueArgs { value: 0 }
        }
    }
    pub struct I64ValueBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> I64ValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_value(&mut self, value: i64) {
            self.fbb_.push_slot::<i64>(I64Value::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> I64ValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            I64ValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<I64Value<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for I64Value<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("I64Value");
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum U64ValueOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct U64Value<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for U64Value<'a> {
        type Inner = U64Value<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> U64Value<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            U64Value { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args U64ValueArgs,
        ) -> flatbuffers::WIPOffset<U64Value<'bldr>> {
            let mut builder = U64ValueBuilder::new(_fbb);
            builder.add_value(args.value);
            builder.finish()
        }

        pub const VT_VALUE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn value(&self) -> u64 {
            self._tab.get::<u64>(U64Value::VT_VALUE, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for U64Value<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct U64ValueArgs {
        pub value: u64,
    }
    impl<'a> Default for U64ValueArgs {
        #[inline]
        fn default() -> Self {
            U64ValueArgs { value: 0 }
        }
    }
    pub struct U64ValueBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> U64ValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_.push_slot::<u64>(U64Value::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> U64ValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            U64ValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<U64Value<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for U64Value<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("U64Value");
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum F64ValueOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct F64Value<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for F64Value<'a> {
        type Inner = F64Value<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> F64Value<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            F64Value { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args F64ValueArgs,
        ) -> flatbuffers::WIPOffset<F64Value<'bldr>> {
            let mut builder = F64ValueBuilder::new(_fbb);
            builder.add_value(args.value);
            builder.finish()
        }

        pub const VT_VALUE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn value(&self) -> f64 {
            self._tab.get::<f64>(F64Value::VT_VALUE, Some(0.0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for F64Value<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<f64>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct F64ValueArgs {
        pub value: f64,
    }
    impl<'a> Default for F64ValueArgs {
        #[inline]
        fn default() -> Self {
            F64ValueArgs { value: 0.0 }
        }
    }
    pub struct F64ValueBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> F64ValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_value(&mut self, value: f64) {
            self.fbb_.push_slot::<f64>(F64Value::VT_VALUE, value, 0.0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> F64ValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            F64ValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<F64Value<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for F64Value<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("F64Value");
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum BoolValueOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BoolValue<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BoolValue<'a> {
        type Inner = BoolValue<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> BoolValue<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BoolValue { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BoolValueArgs,
        ) -> flatbuffers::WIPOffset<BoolValue<'bldr>> {
            let mut builder = BoolValueBuilder::new(_fbb);
            builder.add_value(args.value);
            builder.finish()
        }

        pub const VT_VALUE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn value(&self) -> bool {
            self._tab
                .get::<bool>(BoolValue::VT_VALUE, Some(false))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for BoolValue<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BoolValueArgs {
        pub value: bool,
    }
    impl<'a> Default for BoolValueArgs {
        #[inline]
        fn default() -> Self {
            BoolValueArgs { value: false }
        }
    }
    pub struct BoolValueBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BoolValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_value(&mut self, value: bool) {
            self.fbb_
                .push_slot::<bool>(BoolValue::VT_VALUE, value, false);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BoolValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BoolValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BoolValue<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for BoolValue<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("BoolValue");
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum StringValueOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct StringValue<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StringValue<'a> {
        type Inner = StringValue<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> StringValue<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StringValue { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StringValueArgs<'args>,
        ) -> flatbuffers::WIPOffset<StringValue<'bldr>> {
            let mut builder = StringValueBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            builder.finish()
        }

        pub const VT_VALUE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn value(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(StringValue::VT_VALUE, None)
        }
    }

    impl flatbuffers::Verifiable for StringValue<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct StringValueArgs<'a> {
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for StringValueArgs<'a> {
        #[inline]
        fn default() -> Self {
            StringValueArgs { value: None }
        }
    }
    pub struct StringValueBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StringValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StringValue::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StringValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StringValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StringValue<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for StringValue<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("StringValue");
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum PointOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Point<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Point<'a> {
        type Inner = Point<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Point<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Point { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PointArgs<'args>,
        ) -> flatbuffers::WIPOffset<Point<'bldr>> {
            let mut builder = PointBuilder::new(_fbb);
            builder.add_time(args.time);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.add_value_type(args.value_type);
            builder.finish()
        }

        pub const VT_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_TIME: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_VALUE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn key(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Point::VT_KEY, None)
        }
        #[inline]
        pub fn time(&self) -> i64 {
            self._tab.get::<i64>(Point::VT_TIME, Some(0)).unwrap()
        }
        #[inline]
        pub fn value_type(&self) -> PointValue {
            self._tab
                .get::<PointValue>(Point::VT_VALUE_TYPE, Some(PointValue::NONE))
                .unwrap()
        }
        #[inline]
        pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Point::VT_VALUE, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_i64value(&self) -> Option<I64Value<'a>> {
            if self.value_type() == PointValue::I64Value {
                self.value().map(I64Value::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_u64value(&self) -> Option<U64Value<'a>> {
            if self.value_type() == PointValue::U64Value {
                self.value().map(U64Value::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_f64value(&self) -> Option<F64Value<'a>> {
            if self.value_type() == PointValue::F64Value {
                self.value().map(F64Value::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_bool_value(&self) -> Option<BoolValue<'a>> {
            if self.value_type() == PointValue::BoolValue {
                self.value().map(BoolValue::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_string_value(&self) -> Option<StringValue<'a>> {
            if self.value_type() == PointValue::StringValue {
                self.value().map(StringValue::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Point<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"key", Self::VT_KEY, false)?
                .visit_field::<i64>(&"time", Self::VT_TIME, false)?
                .visit_union::<PointValue, _>(
                    &"value_type",
                    Self::VT_VALUE_TYPE,
                    &"value",
                    Self::VT_VALUE,
                    false,
                    |key, v, pos| match key {
                        PointValue::I64Value => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<I64Value>>(
                                "PointValue::I64Value",
                                pos,
                            ),
                        PointValue::U64Value => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<U64Value>>(
                                "PointValue::U64Value",
                                pos,
                            ),
                        PointValue::F64Value => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<F64Value>>(
                                "PointValue::F64Value",
                                pos,
                            ),
                        PointValue::BoolValue => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<BoolValue>>(
                                "PointValue::BoolValue",
                                pos,
                            ),
                        PointValue::StringValue => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<StringValue>>(
                                "PointValue::StringValue",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PointArgs<'a> {
        pub key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub time: i64,
        pub value_type: PointValue,
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for PointArgs<'a> {
        #[inline]
        fn default() -> Self {
            PointArgs {
                key: None,
                time: 0,
                value_type: PointValue::NONE,
                value: None,
            }
        }
    }
    pub struct PointBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PointBuilder<'a, 'b> {
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Point::VT_KEY, key);
        }
        #[inline]
        pub fn add_time(&mut self, time: i64) {
            self.fbb_.push_slot::<i64>(Point::VT_TIME, time, 0);
        }
        #[inline]
        pub fn add_value_type(&mut self, value_type: PointValue) {
            self.fbb_
                .push_slot::<PointValue>(Point::VT_VALUE_TYPE, value_type, PointValue::NONE);
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Point::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PointBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PointBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Point<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Point<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Point");
            ds.field("key", &self.key());
            ds.field("time", &self.time());
            ds.field("value_type", &self.value_type());
            match self.value_type() {
                PointValue::I64Value => {
                    if let Some(x) = self.value_as_i64value() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                PointValue::U64Value => {
                    if let Some(x) = self.value_as_u64value() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                PointValue::F64Value => {
                    if let Some(x) = self.value_as_f64value() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                PointValue::BoolValue => {
                    if let Some(x) = self.value_as_bool_value() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                PointValue::StringValue => {
                    if let Some(x) = self.value_as_string_value() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("value", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum DeleteOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Delete<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Delete<'a> {
        type Inner = Delete<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Delete<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Delete { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DeleteArgs<'args>,
        ) -> flatbuffers::WIPOffset<Delete<'bldr>> {
            let mut builder = DeleteBuilder::new(_fbb);
            builder.add_stop_time(args.stop_time);
            builder.add_start_time(args.start_time);
            if let Some(x) = args.predicate {
                builder.add_predicate(x);
            }
            builder.finish()
        }

        pub const VT_PREDICATE: flatbuffers::VOffsetT = 4;
        pub const VT_START_TIME: flatbuffers::VOffsetT = 6;
        pub const VT_STOP_TIME: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn predicate(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Delete::VT_PREDICATE, None)
        }
        #[inline]
        pub fn start_time(&self) -> i64 {
            self._tab
                .get::<i64>(Delete::VT_START_TIME, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn stop_time(&self) -> i64 {
            self._tab.get::<i64>(Delete::VT_STOP_TIME, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for Delete<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    &"predicate",
                    Self::VT_PREDICATE,
                    false,
                )?
                .visit_field::<i64>(&"start_time", Self::VT_START_TIME, false)?
                .visit_field::<i64>(&"stop_time", Self::VT_STOP_TIME, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DeleteArgs<'a> {
        pub predicate: Option<flatbuffers::WIPOffset<&'a str>>,
        pub start_time: i64,
        pub stop_time: i64,
    }
    impl<'a> Default for DeleteArgs<'a> {
        #[inline]
        fn default() -> Self {
            DeleteArgs {
                predicate: None,
                start_time: 0,
                stop_time: 0,
            }
        }
    }
    pub struct DeleteBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DeleteBuilder<'a, 'b> {
        #[inline]
        pub fn add_predicate(&mut self, predicate: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Delete::VT_PREDICATE, predicate);
        }
        #[inline]
        pub fn add_start_time(&mut self, start_time: i64) {
            self.fbb_
                .push_slot::<i64>(Delete::VT_START_TIME, start_time, 0);
        }
        #[inline]
        pub fn add_stop_time(&mut self, stop_time: i64) {
            self.fbb_
                .push_slot::<i64>(Delete::VT_STOP_TIME, stop_time, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DeleteBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DeleteBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Delete<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Delete<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Delete");
            ds.field("predicate", &self.predicate());
            ds.field("start_time", &self.start_time());
            ds.field("stop_time", &self.stop_time());
            ds.finish()
        }
    }
    pub enum SegmentOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Segment<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Segment<'a> {
        type Inner = Segment<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Segment<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Segment { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SegmentArgs<'args>,
        ) -> flatbuffers::WIPOffset<Segment<'bldr>> {
            let mut builder = SegmentBuilder::new(_fbb);
            builder.add_id(args.id);
            if let Some(x) = args.writes {
                builder.add_writes(x);
            }
            builder.add_writer_id(args.writer_id);
            builder.finish()
        }

        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_WRITER_ID: flatbuffers::VOffsetT = 6;
        pub const VT_WRITES: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn id(&self) -> u64 {
            self._tab.get::<u64>(Segment::VT_ID, Some(0)).unwrap()
        }
        #[inline]
        pub fn writer_id(&self) -> u32 {
            self._tab
                .get::<u32>(Segment::VT_WRITER_ID, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn writes(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ReplicatedWriteData<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ReplicatedWriteData>>,
            >>(Segment::VT_WRITES, None)
        }
    }

    impl flatbuffers::Verifiable for Segment<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>(&"id", Self::VT_ID, false)?
                .visit_field::<u32>(&"writer_id", Self::VT_WRITER_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ReplicatedWriteData>>,
                >>(&"writes", Self::VT_WRITES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SegmentArgs<'a> {
        pub id: u64,
        pub writer_id: u32,
        pub writes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ReplicatedWriteData<'a>>>,
            >,
        >,
    }
    impl<'a> Default for SegmentArgs<'a> {
        #[inline]
        fn default() -> Self {
            SegmentArgs {
                id: 0,
                writer_id: 0,
                writes: None,
            }
        }
    }
    pub struct SegmentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SegmentBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: u64) {
            self.fbb_.push_slot::<u64>(Segment::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_writer_id(&mut self, writer_id: u32) {
            self.fbb_
                .push_slot::<u32>(Segment::VT_WRITER_ID, writer_id, 0);
        }
        #[inline]
        pub fn add_writes(
            &mut self,
            writes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ReplicatedWriteData<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Segment::VT_WRITES, writes);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SegmentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SegmentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Segment<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Segment<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Segment");
            ds.field("id", &self.id());
            ds.field("writer_id", &self.writer_id());
            ds.field("writes", &self.writes());
            ds.finish()
        }
    }
    pub enum ReplicatedWriteDataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ReplicatedWriteData<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ReplicatedWriteData<'a> {
        type Inner = ReplicatedWriteData<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ReplicatedWriteData<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ReplicatedWriteData { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ReplicatedWriteDataArgs<'args>,
        ) -> flatbuffers::WIPOffset<ReplicatedWriteData<'bldr>> {
            let mut builder = ReplicatedWriteDataBuilder::new(_fbb);
            if let Some(x) = args.payload {
                builder.add_payload(x);
            }
            builder.finish()
        }

        pub const VT_PAYLOAD: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn payload(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    ReplicatedWriteData::VT_PAYLOAD,
                    None,
                )
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for ReplicatedWriteData<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"payload",
                    Self::VT_PAYLOAD,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ReplicatedWriteDataArgs<'a> {
        pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for ReplicatedWriteDataArgs<'a> {
        #[inline]
        fn default() -> Self {
            ReplicatedWriteDataArgs { payload: None }
        }
    }
    pub struct ReplicatedWriteDataBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReplicatedWriteDataBuilder<'a, 'b> {
        #[inline]
        pub fn add_payload(
            &mut self,
            payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ReplicatedWriteData::VT_PAYLOAD,
                payload,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ReplicatedWriteDataBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReplicatedWriteDataBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ReplicatedWriteData<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ReplicatedWriteData<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ReplicatedWriteData");
            ds.field("payload", &self.payload());
            ds.finish()
        }
    }
    pub enum WriterSummaryOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct WriterSummary<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for WriterSummary<'a> {
        type Inner = WriterSummary<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> WriterSummary<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            WriterSummary { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args WriterSummaryArgs,
        ) -> flatbuffers::WIPOffset<WriterSummary<'bldr>> {
            let mut builder = WriterSummaryBuilder::new(_fbb);
            builder.add_end_sequence(args.end_sequence);
            builder.add_start_sequence(args.start_sequence);
            builder.add_writer_id(args.writer_id);
            builder.add_missing_sequences(args.missing_sequences);
            builder.finish()
        }

        pub const VT_WRITER_ID: flatbuffers::VOffsetT = 4;
        pub const VT_START_SEQUENCE: flatbuffers::VOffsetT = 6;
        pub const VT_END_SEQUENCE: flatbuffers::VOffsetT = 8;
        pub const VT_MISSING_SEQUENCES: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn writer_id(&self) -> u64 {
            self._tab
                .get::<u64>(WriterSummary::VT_WRITER_ID, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn start_sequence(&self) -> u64 {
            self._tab
                .get::<u64>(WriterSummary::VT_START_SEQUENCE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn end_sequence(&self) -> u64 {
            self._tab
                .get::<u64>(WriterSummary::VT_END_SEQUENCE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn missing_sequences(&self) -> bool {
            self._tab
                .get::<bool>(WriterSummary::VT_MISSING_SEQUENCES, Some(false))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for WriterSummary<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>(&"writer_id", Self::VT_WRITER_ID, false)?
                .visit_field::<u64>(&"start_sequence", Self::VT_START_SEQUENCE, false)?
                .visit_field::<u64>(&"end_sequence", Self::VT_END_SEQUENCE, false)?
                .visit_field::<bool>(&"missing_sequences", Self::VT_MISSING_SEQUENCES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct WriterSummaryArgs {
        pub writer_id: u64,
        pub start_sequence: u64,
        pub end_sequence: u64,
        pub missing_sequences: bool,
    }
    impl<'a> Default for WriterSummaryArgs {
        #[inline]
        fn default() -> Self {
            WriterSummaryArgs {
                writer_id: 0,
                start_sequence: 0,
                end_sequence: 0,
                missing_sequences: false,
            }
        }
    }
    pub struct WriterSummaryBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> WriterSummaryBuilder<'a, 'b> {
        #[inline]
        pub fn add_writer_id(&mut self, writer_id: u64) {
            self.fbb_
                .push_slot::<u64>(WriterSummary::VT_WRITER_ID, writer_id, 0);
        }
        #[inline]
        pub fn add_start_sequence(&mut self, start_sequence: u64) {
            self.fbb_
                .push_slot::<u64>(WriterSummary::VT_START_SEQUENCE, start_sequence, 0);
        }
        #[inline]
        pub fn add_end_sequence(&mut self, end_sequence: u64) {
            self.fbb_
                .push_slot::<u64>(WriterSummary::VT_END_SEQUENCE, end_sequence, 0);
        }
        #[inline]
        pub fn add_missing_sequences(&mut self, missing_sequences: bool) {
            self.fbb_.push_slot::<bool>(
                WriterSummary::VT_MISSING_SEQUENCES,
                missing_sequences,
                false,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> WriterSummaryBuilder<'a, 'b> {
            let start = _fbb.start_table();
            WriterSummaryBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<WriterSummary<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for WriterSummary<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("WriterSummary");
            ds.field("writer_id", &self.writer_id());
            ds.field("start_sequence", &self.start_sequence());
            ds.field("end_sequence", &self.end_sequence());
            ds.field("missing_sequences", &self.missing_sequences());
            ds.finish()
        }
    }
    pub enum ReplicatedWriteOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ReplicatedWrite<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ReplicatedWrite<'a> {
        type Inner = ReplicatedWrite<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> ReplicatedWrite<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ReplicatedWrite { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ReplicatedWriteArgs<'args>,
        ) -> flatbuffers::WIPOffset<ReplicatedWrite<'bldr>> {
            let mut builder = ReplicatedWriteBuilder::new(_fbb);
            builder.add_sequence(args.sequence);
            if let Some(x) = args.payload {
                builder.add_payload(x);
            }
            builder.add_checksum(args.checksum);
            builder.add_writer(args.writer);
            builder.finish()
        }

        pub const VT_WRITER: flatbuffers::VOffsetT = 4;
        pub const VT_SEQUENCE: flatbuffers::VOffsetT = 6;
        pub const VT_CHECKSUM: flatbuffers::VOffsetT = 8;
        pub const VT_PAYLOAD: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn writer(&self) -> u32 {
            self._tab
                .get::<u32>(ReplicatedWrite::VT_WRITER, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn sequence(&self) -> u64 {
            self._tab
                .get::<u64>(ReplicatedWrite::VT_SEQUENCE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn checksum(&self) -> u32 {
            self._tab
                .get::<u32>(ReplicatedWrite::VT_CHECKSUM, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn payload(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    ReplicatedWrite::VT_PAYLOAD,
                    None,
                )
                .map(|v| v.safe_slice())
        }
    }

    impl flatbuffers::Verifiable for ReplicatedWrite<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>(&"writer", Self::VT_WRITER, false)?
                .visit_field::<u64>(&"sequence", Self::VT_SEQUENCE, false)?
                .visit_field::<u32>(&"checksum", Self::VT_CHECKSUM, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    &"payload",
                    Self::VT_PAYLOAD,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ReplicatedWriteArgs<'a> {
        pub writer: u32,
        pub sequence: u64,
        pub checksum: u32,
        pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for ReplicatedWriteArgs<'a> {
        #[inline]
        fn default() -> Self {
            ReplicatedWriteArgs {
                writer: 0,
                sequence: 0,
                checksum: 0,
                payload: None,
            }
        }
    }
    pub struct ReplicatedWriteBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReplicatedWriteBuilder<'a, 'b> {
        #[inline]
        pub fn add_writer(&mut self, writer: u32) {
            self.fbb_
                .push_slot::<u32>(ReplicatedWrite::VT_WRITER, writer, 0);
        }
        #[inline]
        pub fn add_sequence(&mut self, sequence: u64) {
            self.fbb_
                .push_slot::<u64>(ReplicatedWrite::VT_SEQUENCE, sequence, 0);
        }
        #[inline]
        pub fn add_checksum(&mut self, checksum: u32) {
            self.fbb_
                .push_slot::<u32>(ReplicatedWrite::VT_CHECKSUM, checksum, 0);
        }
        #[inline]
        pub fn add_payload(
            &mut self,
            payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ReplicatedWrite::VT_PAYLOAD,
                payload,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ReplicatedWriteBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReplicatedWriteBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ReplicatedWrite<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for ReplicatedWrite<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("ReplicatedWrite");
            ds.field("writer", &self.writer());
            ds.field("sequence", &self.sequence());
            ds.field("checksum", &self.checksum());
            ds.field("payload", &self.payload());
            ds.finish()
        }
    }
    pub enum WriteBufferBatchOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct WriteBufferBatch<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for WriteBufferBatch<'a> {
        type Inner = WriteBufferBatch<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> WriteBufferBatch<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            WriteBufferBatch { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args WriteBufferBatchArgs<'args>,
        ) -> flatbuffers::WIPOffset<WriteBufferBatch<'bldr>> {
            let mut builder = WriteBufferBatchBuilder::new(_fbb);
            if let Some(x) = args.entries {
                builder.add_entries(x);
            }
            builder.finish()
        }

        pub const VT_ENTRIES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn entries(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WriteBufferEntry<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WriteBufferEntry>>,
            >>(WriteBufferBatch::VT_ENTRIES, None)
        }
    }

    impl flatbuffers::Verifiable for WriteBufferBatch<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WriteBufferEntry>>,
                >>(&"entries", Self::VT_ENTRIES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct WriteBufferBatchArgs<'a> {
        pub entries: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WriteBufferEntry<'a>>>,
            >,
        >,
    }
    impl<'a> Default for WriteBufferBatchArgs<'a> {
        #[inline]
        fn default() -> Self {
            WriteBufferBatchArgs { entries: None }
        }
    }
    pub struct WriteBufferBatchBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> WriteBufferBatchBuilder<'a, 'b> {
        #[inline]
        pub fn add_entries(
            &mut self,
            entries: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<WriteBufferEntry<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                WriteBufferBatch::VT_ENTRIES,
                entries,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> WriteBufferBatchBuilder<'a, 'b> {
            let start = _fbb.start_table();
            WriteBufferBatchBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<WriteBufferBatch<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for WriteBufferBatch<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("WriteBufferBatch");
            ds.field("entries", &self.entries());
            ds.finish()
        }
    }
    pub enum WriteBufferEntryOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct WriteBufferEntry<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for WriteBufferEntry<'a> {
        type Inner = WriteBufferEntry<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> WriteBufferEntry<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            WriteBufferEntry { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args WriteBufferEntryArgs<'args>,
        ) -> flatbuffers::WIPOffset<WriteBufferEntry<'bldr>> {
            let mut builder = WriteBufferEntryBuilder::new(_fbb);
            if let Some(x) = args.delete {
                builder.add_delete(x);
            }
            if let Some(x) = args.table_batches {
                builder.add_table_batches(x);
            }
            if let Some(x) = args.partition_key {
                builder.add_partition_key(x);
            }
            builder.finish()
        }

        pub const VT_PARTITION_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_TABLE_BATCHES: flatbuffers::VOffsetT = 6;
        pub const VT_DELETE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn partition_key(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(WriteBufferEntry::VT_PARTITION_KEY, None)
        }
        #[inline]
        pub fn table_batches(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableWriteBatch<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableWriteBatch>>,
            >>(WriteBufferEntry::VT_TABLE_BATCHES, None)
        }
        #[inline]
        pub fn delete(&self) -> Option<WriteBufferDelete<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<WriteBufferDelete>>(
                    WriteBufferEntry::VT_DELETE,
                    None,
                )
        }
    }

    impl flatbuffers::Verifiable for WriteBufferEntry<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    &"partition_key",
                    Self::VT_PARTITION_KEY,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TableWriteBatch>>,
                >>(&"table_batches", Self::VT_TABLE_BATCHES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<WriteBufferDelete>>(
                    &"delete",
                    Self::VT_DELETE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct WriteBufferEntryArgs<'a> {
        pub partition_key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub table_batches: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableWriteBatch<'a>>>,
            >,
        >,
        pub delete: Option<flatbuffers::WIPOffset<WriteBufferDelete<'a>>>,
    }
    impl<'a> Default for WriteBufferEntryArgs<'a> {
        #[inline]
        fn default() -> Self {
            WriteBufferEntryArgs {
                partition_key: None,
                table_batches: None,
                delete: None,
            }
        }
    }
    pub struct WriteBufferEntryBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> WriteBufferEntryBuilder<'a, 'b> {
        #[inline]
        pub fn add_partition_key(&mut self, partition_key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                WriteBufferEntry::VT_PARTITION_KEY,
                partition_key,
            );
        }
        #[inline]
        pub fn add_table_batches(
            &mut self,
            table_batches: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TableWriteBatch<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                WriteBufferEntry::VT_TABLE_BATCHES,
                table_batches,
            );
        }
        #[inline]
        pub fn add_delete(&mut self, delete: flatbuffers::WIPOffset<WriteBufferDelete<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<WriteBufferDelete>>(
                    WriteBufferEntry::VT_DELETE,
                    delete,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> WriteBufferEntryBuilder<'a, 'b> {
            let start = _fbb.start_table();
            WriteBufferEntryBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<WriteBufferEntry<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for WriteBufferEntry<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("WriteBufferEntry");
            ds.field("partition_key", &self.partition_key());
            ds.field("table_batches", &self.table_batches());
            ds.field("delete", &self.delete());
            ds.finish()
        }
    }
    pub enum TableWriteBatchOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TableWriteBatch<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TableWriteBatch<'a> {
        type Inner = TableWriteBatch<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> TableWriteBatch<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TableWriteBatch { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TableWriteBatchArgs<'args>,
        ) -> flatbuffers::WIPOffset<TableWriteBatch<'bldr>> {
            let mut builder = TableWriteBatchBuilder::new(_fbb);
            if let Some(x) = args.rows {
                builder.add_rows(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_ROWS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TableWriteBatch::VT_NAME, None)
        }
        #[inline]
        pub fn rows(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Row<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Row>>,
            >>(TableWriteBatch::VT_ROWS, None)
        }
    }

    impl flatbuffers::Verifiable for TableWriteBatch<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Row>>,
                >>(&"rows", Self::VT_ROWS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TableWriteBatchArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub rows: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Row<'a>>>>,
        >,
    }
    impl<'a> Default for TableWriteBatchArgs<'a> {
        #[inline]
        fn default() -> Self {
            TableWriteBatchArgs {
                name: None,
                rows: None,
            }
        }
    }
    pub struct TableWriteBatchBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TableWriteBatchBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TableWriteBatch::VT_NAME, name);
        }
        #[inline]
        pub fn add_rows(
            &mut self,
            rows: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Row<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TableWriteBatch::VT_ROWS, rows);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TableWriteBatchBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TableWriteBatchBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TableWriteBatch<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for TableWriteBatch<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("TableWriteBatch");
            ds.field("name", &self.name());
            ds.field("rows", &self.rows());
            ds.finish()
        }
    }
    pub enum RowOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Row<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Row<'a> {
        type Inner = Row<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Row<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Row { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RowArgs<'args>,
        ) -> flatbuffers::WIPOffset<Row<'bldr>> {
            let mut builder = RowBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value>>,
            >>(Row::VT_VALUES, None)
        }
    }

    impl flatbuffers::Verifiable for Row<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Value>>,
                >>(&"values", Self::VT_VALUES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RowArgs<'a> {
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>,
            >,
        >,
    }
    impl<'a> Default for RowArgs<'a> {
        #[inline]
        fn default() -> Self {
            RowArgs { values: None }
        }
    }
    pub struct RowBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RowBuilder<'a, 'b> {
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Value<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Row::VT_VALUES, values);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RowBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RowBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Row<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Row<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Row");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    pub enum TagValueOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TagValue<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TagValue<'a> {
        type Inner = TagValue<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> TagValue<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TagValue { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TagValueArgs<'args>,
        ) -> flatbuffers::WIPOffset<TagValue<'bldr>> {
            let mut builder = TagValueBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            builder.finish()
        }

        pub const VT_VALUE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn value(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TagValue::VT_VALUE, None)
        }
    }

    impl flatbuffers::Verifiable for TagValue<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TagValueArgs<'a> {
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for TagValueArgs<'a> {
        #[inline]
        fn default() -> Self {
            TagValueArgs { value: None }
        }
    }
    pub struct TagValueBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TagValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TagValue::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TagValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TagValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TagValue<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for TagValue<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("TagValue");
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum ValueOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Value<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Value<'a> {
        type Inner = Value<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Value<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Value { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ValueArgs<'args>,
        ) -> flatbuffers::WIPOffset<Value<'bldr>> {
            let mut builder = ValueBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.column {
                builder.add_column(x);
            }
            builder.add_value_type(args.value_type);
            builder.finish()
        }

        pub const VT_COLUMN: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn column(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Value::VT_COLUMN, None)
        }
        #[inline]
        pub fn value_type(&self) -> ColumnValue {
            self._tab
                .get::<ColumnValue>(Value::VT_VALUE_TYPE, Some(ColumnValue::NONE))
                .unwrap()
        }
        #[inline]
        pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Value::VT_VALUE, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_tag_value(&self) -> Option<TagValue<'a>> {
            if self.value_type() == ColumnValue::TagValue {
                self.value().map(TagValue::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_i64value(&self) -> Option<I64Value<'a>> {
            if self.value_type() == ColumnValue::I64Value {
                self.value().map(I64Value::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_u64value(&self) -> Option<U64Value<'a>> {
            if self.value_type() == ColumnValue::U64Value {
                self.value().map(U64Value::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_f64value(&self) -> Option<F64Value<'a>> {
            if self.value_type() == ColumnValue::F64Value {
                self.value().map(F64Value::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_bool_value(&self) -> Option<BoolValue<'a>> {
            if self.value_type() == ColumnValue::BoolValue {
                self.value().map(BoolValue::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn value_as_string_value(&self) -> Option<StringValue<'a>> {
            if self.value_type() == ColumnValue::StringValue {
                self.value().map(StringValue::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Value<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    &"column",
                    Self::VT_COLUMN,
                    false,
                )?
                .visit_union::<ColumnValue, _>(
                    &"value_type",
                    Self::VT_VALUE_TYPE,
                    &"value",
                    Self::VT_VALUE,
                    false,
                    |key, v, pos| match key {
                        ColumnValue::TagValue => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<TagValue>>(
                                "ColumnValue::TagValue",
                                pos,
                            ),
                        ColumnValue::I64Value => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<I64Value>>(
                                "ColumnValue::I64Value",
                                pos,
                            ),
                        ColumnValue::U64Value => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<U64Value>>(
                                "ColumnValue::U64Value",
                                pos,
                            ),
                        ColumnValue::F64Value => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<F64Value>>(
                                "ColumnValue::F64Value",
                                pos,
                            ),
                        ColumnValue::BoolValue => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<BoolValue>>(
                                "ColumnValue::BoolValue",
                                pos,
                            ),
                        ColumnValue::StringValue => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<StringValue>>(
                                "ColumnValue::StringValue",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ValueArgs<'a> {
        pub column: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value_type: ColumnValue,
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ValueArgs<'a> {
        #[inline]
        fn default() -> Self {
            ValueArgs {
                column: None,
                value_type: ColumnValue::NONE,
                value: None,
            }
        }
    }
    pub struct ValueBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_column(&mut self, column: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Value::VT_COLUMN, column);
        }
        #[inline]
        pub fn add_value_type(&mut self, value_type: ColumnValue) {
            self.fbb_
                .push_slot::<ColumnValue>(Value::VT_VALUE_TYPE, value_type, ColumnValue::NONE);
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Value::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Value<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Value<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Value");
            ds.field("column", &self.column());
            ds.field("value_type", &self.value_type());
            match self.value_type() {
                ColumnValue::TagValue => {
                    if let Some(x) = self.value_as_tag_value() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ColumnValue::I64Value => {
                    if let Some(x) = self.value_as_i64value() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ColumnValue::U64Value => {
                    if let Some(x) = self.value_as_u64value() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ColumnValue::F64Value => {
                    if let Some(x) = self.value_as_f64value() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ColumnValue::BoolValue => {
                    if let Some(x) = self.value_as_bool_value() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ColumnValue::StringValue => {
                    if let Some(x) = self.value_as_string_value() {
                        ds.field("value", &x)
                    } else {
                        ds.field(
                            "value",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("value", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum WriteBufferDeleteOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct WriteBufferDelete<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for WriteBufferDelete<'a> {
        type Inner = WriteBufferDelete<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> WriteBufferDelete<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            WriteBufferDelete { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args WriteBufferDeleteArgs<'args>,
        ) -> flatbuffers::WIPOffset<WriteBufferDelete<'bldr>> {
            let mut builder = WriteBufferDeleteBuilder::new(_fbb);
            if let Some(x) = args.predicate {
                builder.add_predicate(x);
            }
            if let Some(x) = args.table_name {
                builder.add_table_name(x);
            }
            builder.finish()
        }

        pub const VT_TABLE_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_PREDICATE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn table_name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(WriteBufferDelete::VT_TABLE_NAME, None)
        }
        #[inline]
        pub fn predicate(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(WriteBufferDelete::VT_PREDICATE, None)
        }
    }

    impl flatbuffers::Verifiable for WriteBufferDelete<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    &"table_name",
                    Self::VT_TABLE_NAME,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    &"predicate",
                    Self::VT_PREDICATE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct WriteBufferDeleteArgs<'a> {
        pub table_name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub predicate: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for WriteBufferDeleteArgs<'a> {
        #[inline]
        fn default() -> Self {
            WriteBufferDeleteArgs {
                table_name: None,
                predicate: None,
            }
        }
    }
    pub struct WriteBufferDeleteBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> WriteBufferDeleteBuilder<'a, 'b> {
        #[inline]
        pub fn add_table_name(&mut self, table_name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                WriteBufferDelete::VT_TABLE_NAME,
                table_name,
            );
        }
        #[inline]
        pub fn add_predicate(&mut self, predicate: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                WriteBufferDelete::VT_PREDICATE,
                predicate,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> WriteBufferDeleteBuilder<'a, 'b> {
            let start = _fbb.start_table();
            WriteBufferDeleteBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<WriteBufferDelete<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for WriteBufferDelete<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("WriteBufferDelete");
            ds.field("table_name", &self.table_name());
            ds.field("predicate", &self.predicate());
            ds.finish()
        }
    }
} // pub mod wal
